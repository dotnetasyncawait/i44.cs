using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;
using Lib.Hotkeys.Constants;
using Lib.Hotkeys.Helpers;
using Lib.Interop;
using static Lib.Interop.User32;
using static Lib.Interop.Constants;
using static Lib.Interop.Structs;

namespace Lib.Hotkeys;

// TODO: disable InconsistentNaming for static fields on the IDE level
// ReSharper disable InconsistentNaming
// ReSharper disable InvertIf

// TODO: rename
public static class Hotkey
{
	private static readonly Dictionary<Entry, HotkeyHandler> _hotkeys = [];
	
	private static readonly Thread _hotkeyThread = new(StartHook);
	private static uint _hotkeyThreadId;
	
	public static void Run()
	{
		if (_hotkeys.Count == 0)
		{
			MapHotkeys();
			_hotkeyThread.Start();
		}
	}
	
	public static void Exit()
	{
		if (!PostThreadMessage(_hotkeyThreadId, WM_QUIT, 0, 0))
		{
			throw new Exception(Marshal.GetLastPInvokeErrorMessage());
		}
		_hotkeyThread.Join();
	}
	
	public static void Wait() => _hotkeyThread.Join();
	
	private static unsafe void StartHook()
	{
		// TODO: If Hotkey.Exit() is called before we happen to initialize this field, PostThreadMessage will fail.
		_hotkeyThreadId = Kernel32.GetCurrentThreadId();
		
		using var hHook = SetWindowsHookEx(WH_KEYBOARD_LL, &LowLevelKeyboardProc, 0, 0);
		
		int res;
		while((res = GetMessage(out var msg, IntPtr.Zero, 0, 0)) != 0)
		{
			if (res == -1)
			{
				throw new Exception(Marshal.GetLastPInvokeErrorMessage());
			}
			_ = TranslateMessage(ref msg);
			_ = DispatchMessage(ref msg);
		}
		
		Console.WriteLine("Message queue is terminated");
		// TODO: call OnExit callbacks? 
	}
	
	private static void MapHotkeys()
	{
		var methods = Assembly.GetEntryAssembly()!
			.GetTypes()
			.SelectMany(t => t.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic))
			.Where(m => m.CustomAttributes.Any(a => a.AttributeType == typeof(HotkeyAttribute)));
		
		foreach (var method in methods)
		{
			HotkeyHandler handler;
			
			if (method.ReturnType == typeof(Remap?)) // remap
			{
				if (method.GetParameters().Length != 0)
				{
					throw new NotImplementedException("Invalid parameters");
				}
				handler = new HotkeyHandler(method.CreateDelegate<Func<Remap?>>());
			}
			// else if (method.ReturnType == typeof(void)) // action
			// {
			// 	var parameters = method.GetParameters();
			// 	if (parameters.Length != 1 || parameters.First().ParameterType != typeof(bool))
			// 	{
			// 		throw new NotImplementedException("Invalid parameters");
			// 	}
			// 	handler = new HotkeyHandler(method.CreateDelegate<Action<bool>>());
			// }
			else
			{
				throw new NotImplementedException("Invalid return type");
			}
			
			foreach (var attribute in method.GetCustomAttributes<HotkeyAttribute>())
			{
				_hotkeys.Add(attribute.Entry, handler);
			}
		}
	}
	private const IntPtr NonZero = 1;
	
	// private static byte _phMods;
	private static byte _vMods;
	
	private static readonly HashSet<ushort> _ignore = [];
	private static readonly List<HotkeyItem> _currentHotkeys = [];
	
	[UnmanagedCallersOnly]
	// The reason for using 'raw pointer' for 'lParam' instead of `ref' is the:
	// error CS8977: Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.
	internal static unsafe IntPtr LowLevelKeyboardProc(int code, UIntPtr wParam, KBDLLHOOKSTRUCT* lParam)
	{
		#region start
		if (code < 0) return CallNextHookEx(0, code, wParam, lParam);
		
		var hookStruct = *lParam;
		
		var info = lParam->ExtraInfo;
		var flags = hookStruct.Flags;
		var sc = (ushort)hookStruct.ScanCode;
		
		// TODO: set known value
		if (info == 0xAABBCCDD) return CallNextHookEx(0, code, wParam, lParam);
		
		// TODO: accept injected keys from other apps? What about Alt_Down + Alt_Up generated by JetBrains Rider
		// on Alt release? Could it cause unwanted behavior?
		
		// if (hookStruct.VkCode == 0xFF) return NonZero;
		
		if ((flags & LLKHF_INJECTED) != 0)
		{
			// Media keys are (for some reason) 'injected', and 'sc' is set to 0. So we fall back on Vk.
			if (sc != 0 || hookStruct.VkCode is < VK_CONSUMER_BEGIN or > VK_CONSUMER_END)
			{
				Console.WriteLine($"Injected key (sc: 0x{sc:X}; vk: 0x{hookStruct.VkCode:X}) is ignored.");
				return CallNextHookEx(0, code, wParam, lParam);
			}
			// It is said that if the scan code is an extended key, the high byte of the returned value will contain
			// either 0xE0 or 0xE1. However, SendInput seems to ignore high byte value and just specifying
			// 'KEYEVENTF_EXTENDEDKEY' flag seems to be enough. So we don't care if it's 0xE0 or 0xE1.
			sc = (ushort)MapVirtualKey(hookStruct.VkCode, MAPVK_VK_TO_VSC_EX);
		}
		else if ((flags & LLKHF_EXTENDED) != 0 && sc != Key.RShift)
		{
			sc |= 0xE000;
		}
		
		var isMod = IsMod(sc, out var modBit);
		bool isPressed = (flags & LLKHF_UP) == 0;
		
		Console.WriteLine($"Sc: 0x{sc:X} is {(isPressed ? "down" : "up")}; Vk: 0x{hookStruct.VkCode:X}; Flags: {flags:b8}; " +
		                  $"Extra: 0x{hookStruct.ExtraInfo:X}; vMods: {_vMods:b8}.");
		
		// return CallNextHookEx(0, code, wParam, lParam);
		
		#endregion
		
		if (isPressed)
		{
			if (_ignore.Contains(sc))
			{
				Console.WriteLine("ignoring...");
				return NonZero;
			}
			
			if (_currentHotkeys.TryGetByEntryKey(sc, out HotkeyItem h))
			{
				var key = h.Remap.Key;
				Console.WriteLine($"Repeat: sc: 0x{sc:X} -> 0x{key:X}; vMods: {_vMods:b8}");
				
				if (sc == key) goto CallNext;
				SendKeyDown(key);
				return NonZero;
			}
			
			var entry = new Entry(_vMods, sc);
			
			if (!_hotkeys.TryGetValue(entry, out var handler))
			{
				goto CallNext;
			}
			
			if (handler.IsAction) throw new NotImplementedException();
			
			if (handler.Remap() is not {} remap)
			{
				goto CallNext;
			}
			
			var remapKeyModBit = ModBit(remap.Key);
			
			var modsToRelease = (byte)(_vMods & ~(remap.Mods | remapKeyModBit));
			var modsToPress   = (byte)(remap.Mods & ~_vMods);
			
			_vMods = (byte)((_vMods | modsToPress | remapKeyModBit) & ~modsToRelease);
			
			_currentHotkeys.Add(new HotkeyItem(entry, remap));
			
			Console.WriteLine($"Remap 0x{sc:X} -> 0x{remap.Key:X}. vMods: {_vMods:b8}");
			
			var ip = new ItemsPacker(stackalloc InputItem[9])
				.ModBitsUp(modsToRelease)
				.ModBitsDown(modsToPress)
				.KeyDown(remap.Key);
			
			SendInput(ip.GetItems());
			return NonZero;
		}
		else
		{
			if (_ignore.Remove(sc))
			{
				Console.WriteLine("ignoring on release");
				return NonZero;
			}
			
			if (_currentHotkeys.Count == 0) goto CallNext;
			
			if (_currentHotkeys.TryPopByEntryKey(sc, out HotkeyItem h))
			{
				// Trigger key is released — revert the hotkey.
				// Note: If one or all of the remap.Mods were already released, we will not consider it and 'release' them anyway.
				
				var modsToRelease = (byte)(h.Remap.Mods & ~h.Entry.Mods);
				var modsToRestore = (byte)(h.Entry.Mods & ~h.Remap.Mods);
				
				_vMods = (byte)((_vMods | modsToRestore) & ~(modsToRelease | ModBit(h.Remap.Key)));
				
				var ip = new ItemsPacker(stackalloc InputItem[9])
					.KeyUp(h.Remap.Key)
					.ModBitsUp(modsToRelease)
					.ModBitsDown(modsToRestore);
				
				SendInput(ip.GetItems());
				return NonZero; // trigger key is ignored
			}
			
			if (!isMod) goto CallNext;
			
			// TODO: can it match more than one?
			if (_currentHotkeys.TryPopByEntryModBit(modBit, out h)) 
			{
				// One of the mods is released — remove all the keys and ignore the entries.
				
				// C+S+a -> A+W+b
				
				_vMods &= (byte)~(h.Remap.Mods | ModBit(h.Remap.Key));
				
				AddEntryHotkeyToIgnoreList((byte)(h.Entry.Mods & ~modBit), h.Entry.Key); // except the released bit
				
				var ip = new ItemsPacker(stackalloc InputItem[9])
					.KeyUp(h.Remap.Key)
					.ModBitsUp(h.Remap.Mods);
				
				SendInput(ip.GetItems());
				return NonZero;
			}
			
			// Fall through to CallNext label
		}
		
		CallNext:
			if (isMod)
			{
				if (isPressed) _vMods |= modBit;
				else _vMods &= (byte)~modBit;
			}
			return CallNextHookEx(0, code, wParam, lParam);
	}
	
	private static void AddEntryHotkeyToIgnoreList(byte modBits, ushort key)
	{
		if (modBits != 0)
		{
			if ((modBits & Mod.LCtrl)  != 0) _ignore.Add(Key.LCtrl);
			if ((modBits & Mod.LShift) != 0) _ignore.Add(Key.LShift);
			if ((modBits & Mod.LAlt)   != 0) _ignore.Add(Key.LAlt);
			if ((modBits & Mod.LWin)   != 0) _ignore.Add(Key.LWin);
			if ((modBits & Mod.RCtrl)  != 0) _ignore.Add(Key.RCtrl);
			if ((modBits & Mod.RShift) != 0) _ignore.Add(Key.RShift);
			if ((modBits & Mod.RAlt)   != 0) _ignore.Add(Key.RAlt);
			if ((modBits & Mod.RWin)   != 0) _ignore.Add(Key.RWin);
		}
		
		_ignore.Add(key);
	}
	
	private static byte ModBit(ushort sc) => sc switch
	{
		Key.LCtrl  => Mod.LCtrl,
		Key.LShift => Mod.LShift,
		Key.LAlt   => Mod.LAlt,
		Key.LWin   => Mod.LWin,
		Key.RCtrl  => Mod.RCtrl,
		Key.RShift => Mod.RShift,
		Key.RAlt   => Mod.RAlt,
		Key.RWin   => Mod.RWin,
		_ => 0
	};
	
	private static bool IsMod(ushort sc, out byte modBit)
	{
		modBit = ModBit(sc);
		return modBit != 0;
	}
	
	private static void SendInput(ReadOnlySpan<InputItem> items)
	{
		Span<INPUT> inputs = stackalloc INPUT[items.Length];
			
		for (int i = 0; i < items.Length; i++)
		{
			var item = items[i];
			inputs[i] = INPUT.KeybdInput(item.Key, item.Flags, 0xAABBCCDD); // TODO:
		}

		_ = User32.SendInput((uint)inputs.Length, ref MemoryMarshal.GetReference(inputs), INPUT.Size);
	}
	
	private static void SendKeyDown(ushort sc) => SendKey(sc, true);
	// private static void SendKeyUp(ushort sc) => SendKey(sc, false);
	
	private static void SendKey(ushort sc, bool state)
	{
		var flags = KEYEVENTF_SCANCODE | (sc >> 8 != 0 ? KEYEVENTF_EXTENDEDKEY : 0) | (state ? 0 : KEYEVENTF_KEYUP);
		
		var input = INPUT.KeybdInput(sc, (uint)flags, 0xAABBCCDD); // TODO:
		_ = User32.SendInput(1, ref input, INPUT.Size);
	}
}

internal ref struct ItemsPacker(Span<InputItem> items) // rename to builder and .Add*?
{
	private readonly Span<InputItem> _items = items;
	private int _index = 0;
	
	internal ItemsPacker ModBitsDown(byte modBits) => PackModBits(modBits, true);
	internal ItemsPacker ModBitsUp(byte modBits) => PackModBits(modBits, false);
	
	internal ItemsPacker KeyDown(ushort key) => PackKey(key, true);
	internal ItemsPacker KeyUp(ushort key) => PackKey(key, false);
	
	internal Span<InputItem> GetItems() => _items[.._index];
	
	private ItemsPacker PackModBits(byte modBits, bool state)
	{
		if (modBits == 0) return this;
		var flags = (ushort)(KEYEVENTF_SCANCODE | (state ? 0 : KEYEVENTF_KEYUP));
		
		if ((modBits & Mod.LCtrl)  != 0) _items[_index++] = new InputItem(Key.LCtrl,  flags);
		if ((modBits & Mod.LShift) != 0) _items[_index++] = new InputItem(Key.LShift, flags);
		if ((modBits & Mod.LAlt)   != 0) _items[_index++] = new InputItem(Key.LAlt,   flags);
		if ((modBits & Mod.LWin)   != 0) _items[_index++] = new InputItem(Key.LWin,   (ushort)(flags | KEYEVENTF_EXTENDEDKEY));
		if ((modBits & Mod.RCtrl)  != 0) _items[_index++] = new InputItem(Key.RCtrl,  (ushort)(flags | KEYEVENTF_EXTENDEDKEY));
		if ((modBits & Mod.RShift) != 0) _items[_index++] = new InputItem(Key.RShift, flags);
		if ((modBits & Mod.RAlt)   != 0) _items[_index++] = new InputItem(Key.RAlt,   (ushort)(flags | KEYEVENTF_EXTENDEDKEY));
		if ((modBits & Mod.RWin)   != 0) _items[_index++] = new InputItem(Key.RWin,   (ushort)(flags | KEYEVENTF_EXTENDEDKEY));
		
		return this;
	}
	
	private ItemsPacker PackKey(ushort key, bool state)
	{
		var flags = KEYEVENTF_SCANCODE | (key >> 8 != 0 ? KEYEVENTF_EXTENDEDKEY : 0) | (state ? 0 : KEYEVENTF_KEYUP);
		_items[_index++] = new InputItem(key, (ushort)flags);
		return this;
	}
}

internal readonly record struct InputItem(ushort Key, ushort Flags);

internal readonly record struct HotkeyItem(Entry Entry, Remap Remap);