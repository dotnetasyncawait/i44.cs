using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;
using Lib.Hotkeys.Constants;
using Lib.Hotkeys.Helpers;
using Lib.Interop;
using static Lib.Hotkeys.Constants.Misc;
using static Lib.Interop.User32;
using static Lib.Interop.Constants;
using static Lib.Interop.Structs;

namespace Lib.Hotkeys;

// ReSharper disable InconsistentNaming

internal readonly record struct RemapItem(Entry Entry, Remap Remap);
internal readonly record struct UnicodeItem(Entry Entry, INPUT[] Inputs);

public static class Hotkey // TODO: rename
{
	private static readonly Dictionary<Entry, HotkeyHandler> _hotkeys = [];
	
	private static readonly Thread _hotkeyThread = new(StartHook);
	private static uint _hotkeyThreadId;
	
	private static byte _vMods;
	
	private static readonly HashSet<ushort> _suppressedKeys = [];
	
	private static RemapItem? _currRemap;
	private static UnicodeItem? _currUnicode;
	
	private static byte _suppressedEntryMods; // QMK key-overrides case
	
	public static void Run()
	{
		if (_hotkeys.Count == 0)
		{
			MapHotkeys();
			_hotkeyThread.Start();
		}
	}
	
	public static void Exit()
	{
		if (!PostThreadMessage(_hotkeyThreadId, WM_QUIT, 0, 0))
		{
			throw new Exception(Marshal.GetLastPInvokeErrorMessage());
		}
	}
	
	public static void Wait() => _hotkeyThread.Join();
	
	private static unsafe void StartHook()
	{
		// TODO: If Hotkey.Exit() is called before we happen to initialize this field, PostThreadMessage will fail.
		_hotkeyThreadId = Kernel32.GetCurrentThreadId();
		
		using var hHook = SetWindowsHookEx(WH_KEYBOARD_LL, &LowLevelKeyboardProc, 0, 0);
		
		int res;
		while((res = GetMessage(out var msg, IntPtr.Zero, 0, 0)) != 0)
		{
			if (res == -1)
			{
				throw new Exception(Marshal.GetLastPInvokeErrorMessage());
			}
			_ = TranslateMessage(ref msg);
			_ = DispatchMessage(ref msg);
		}
		
		Console.WriteLine("Message queue is terminated");
		// TODO: call OnExit callbacks? 
	}
	
	private static void MapHotkeys()
	{
		var methods = Assembly.GetEntryAssembly()!
			.GetTypes()
			.SelectMany(t => t.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic))
			.Where(m => m.CustomAttributes.Any(a => a.AttributeType == typeof(HotkeyAttribute)));
		
		foreach (var method in methods)
		{
			HotkeyHandler handler;
			
			if (method.ReturnType == typeof(Remap?)) // remap
			{
				if (method.GetParameters().Length != 0)
				{
					throw new NotImplementedException("Invalid parameters");
				}
				handler = new HotkeyHandler(method.CreateDelegate<Func<Remap?>>());
			}
			else if (method.ReturnType == typeof(string)) // unicode
			{
				if (method.GetParameters().Length != 0)
				{
					throw new NotImplementedException("Invalid parameters");
				}
				handler = new HotkeyHandler(method.CreateDelegate<Func<string>>());
			}
			// else if (method.ReturnType == typeof(void)) // action
			// {
			// 	var parameters = method.GetParameters();
			// 	if (parameters.Length != 1 || parameters.First().ParameterType != typeof(bool))
			// 	{
			// 		throw new NotImplementedException("Invalid parameters");
			// 	}
			// 	handler = new HotkeyHandler(method.CreateDelegate<Action<bool>>());
			// }
			else
			{
				throw new NotImplementedException("Invalid return type");
			}
			
			foreach (var attribute in method.GetCustomAttributes<HotkeyAttribute>())
			{
				_hotkeys.Add(attribute.Entry, handler);
			}
		}
	}
	
	[UnmanagedCallersOnly]
	// The reason for using 'raw pointer' for 'lParam' instead of `ref' is the:
	// error CS8977: Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.
	internal static unsafe nint LowLevelKeyboardProc(int code, nuint wParam, KBDLLHOOKSTRUCT* lParam)
	{
		if (code < 0) goto CallNext;
		
		var hookStruct = *lParam;
		
		var extra = hookStruct.dwExtraInfo;
		if (extra == MAGNUM_CALLNEXT) goto CallNext;
		
		var flags = hookStruct.flags;
		var sc = (ushort)hookStruct.scanCode;
		
		// TODO: accept injected keys from other apps? What about Alt_Down + Alt_Up generated by JetBrains Rider
		// on Alt release? Could it cause unwanted behavior?
		if ((flags & LLKHF_INJECTED) != 0)
		{
			// Media keys are (for some reason) 'injected', and 'sc' is set to 0. So we fall back on Vk.
			if (sc != 0 || hookStruct.vkCode is < VK_CONSUMER_BEGIN or > VK_CONSUMER_END)
			{
				Console.WriteLine($"Ignore injected: 0x{sc:X} (vk 0x{hookStruct.vkCode:X})");
				return CallNextHookEx(0, code, wParam, lParam);
			}
			
			// It is said that if the scan code is an extended key, the high byte of the returned value will contain
			// either 0xE0 or 0xE1. However, SendInput seems to ignore high byte value and just specifying
			// 'KEYEVENTF_EXTENDEDKEY' flag seems to be enough. So the possible discrepancy should not bother.
			sc = (ushort)MapVirtualKey(hookStruct.vkCode, MAPVK_VK_TO_VSC_EX);
		}
		else if ((flags & LLKHF_EXTENDED) != 0 && sc != Key.RShift)
		{
			sc |= 0xE000;
		}
		
		bool isPressed = (flags & LLKHF_UP) == 0;
		bool isMod = IsMod(sc, out byte modBit);
		
		Console.WriteLine($"{(isPressed ? "Down" : "Up")}: 0x{sc:X} ({_vMods:b8}); flags: {flags:b8}; extra: 0x{extra:X}");
		
		if (isPressed)
		{
			if (HandleKbKeyDown(sc, isMod, modBit)) return NonZero;
			if (isMod) _vMods |= modBit;
		}
		else
		{
			if (HandleKbKeyUp(sc, isMod, modBit)) return NonZero;
			if (isMod) _vMods &= (byte)~modBit;
		}
		
		Console.WriteLine($"Pass next: 0x{sc:X} ({_vMods:b8})");
		
		CallNext:
		return CallNextHookEx(0, code, wParam, lParam);
	}
	
	private static bool HandleKbKeyDown(ushort sc, bool isMod, byte modBit)
	{
		if (_suppressedKeys.Contains(sc))
		{
			Console.WriteLine($"Suppress key down: 0x{sc:X}");
			return true;
		}
		
		if (_currRemap is {} h)
		{
			Debug.Assert(_currUnicode is null);
			
			if (h.Entry.Key == sc)
			{
				var remapKey = h.Remap.Key;
				Console.WriteLine($"Repeat: {h.Entry.Mods:b8}_0x{sc:X} -> {h.Remap.Mods:b8}_0x{remapKey:X} ({_vMods:b8})");
				
				if (sc == remapKey) return false;
				SendKeyDown(remapKey);
				return true;
			}
			
			if (isMod && (_suppressedEntryMods & modBit) != 0)
			{
				Console.WriteLine($"Suppress entry mod: 0x{sc:X}");
				return true;
			}
			
			// TODO: implement compositional hotkeys (for mod-to-mod)?
			return false;
		}
		
		if (_currUnicode is {} u)
		{
			if (u.Entry.Key == sc)
			{
				Console.WriteLine("Repeat Unicode");
				SendInput((uint)u.Inputs.Length, ref MemoryMarshal.GetReference(u.Inputs), INPUT.Size);
				return true;
			}
			
			if (isMod && (_suppressedEntryMods & modBit) != 0)
			{
				Console.WriteLine($"Suppress entry mod: 0x{sc:X}");
				return true;
			}
			
			return false;
		}
		
		var entry = new Entry(_vMods, sc);
		
		if (!_hotkeys.TryGetValue(entry, out var handler)) return false;
		
		if (handler.IsAction)
		{
			throw new NotImplementedException();
		}
		
		if (handler.IsUnicode)
		{
			return handler.Unicode() is {} str && HandleUnicodeDown(entry, str);
		}
		
		Debug.Assert(handler.IsRemap);
		return handler.Remap() is {} remap && HandleRemapDown(entry, remap);
	}

	private static bool HandleKbKeyUp(ushort sc, bool isMod, byte modBit)
	{
		if (_suppressedKeys.Remove(sc))
		{
			Console.WriteLine($"Suppress key up: 0x{sc:X}");
			return true;
		}
		
		if (_currUnicode is {} u)
		{
			Debug.Assert(_currRemap is null);
			byte modsToRestore;
			
			if (u.Entry.Key == sc)
			{
				modsToRestore = u.Entry.Mods;
			}
			else if (isMod && (u.Entry.Mods & modBit) != 0)
			{
				modsToRestore = (byte)(u.Entry.Mods & ~modBit);
				_suppressedKeys.Add(u.Entry.Key);
			}
			else return false;
			
			_vMods |= modsToRestore;
			_currUnicode = null;
			_suppressedEntryMods = 0;
			
			if (modsToRestore != 0)
			{
				UpdateModsMaskedUnicode(modsToRestore, true);
			}
			return true;
		}
		
		if (_currRemap is not {} h) return false;
		
		if (h.Entry.Key == sc)
		{
			// Trigger key is released — revert the hotkey.
			// Note: If one or all of the 'Remap.Mods' were already released, they will not be considered and
			// will be 'released' anyway. Can that be undesired?
			
			var modsToRelease = (byte)(h.Remap.Mods & ~h.Entry.Mods);
			var modsToRestore = (byte)(h.Entry.Mods & ~h.Remap.Mods);
			
			_vMods = (byte)((_vMods | modsToRestore) & ~(modsToRelease | ModBit(h.Remap.Key)));
			_currRemap = null;
			_suppressedEntryMods = 0;
			
			// TODO: MenuMask
			
			new KeySender(stackalloc InputItem[9])
				.KeyUp(h.Remap.Key)
				.ModsUp(modsToRelease)
				.ModsDown(modsToRestore)
				.Send();
			
			return true;
		}
		
		if (isMod && (h.Entry.Mods & modBit) != 0)
		{
			// One of the 'Entry.Mods' is released — remove all the keys and ignore the entries.
			
			_vMods &= (byte)~(h.Remap.Mods | ModBit(h.Remap.Key));
			_currRemap = null;
			_suppressedEntryMods = 0;
			
			AddKeysToIgnoreList((byte)(h.Entry.Mods & ~modBit), h.Entry.Key); // exclude the released bit
			
			// TODO: MenuMask
			// TODO: restore physically held mods?
			
			new KeySender(stackalloc InputItem[9])
				.KeyUp(h.Remap.Key)
				.ModsUp(h.Remap.Mods)
				.Send();
			
			return true;
		}
		
		return false;
	}
	
	private static bool HandleRemapDown(Entry entry, Remap remap)
	{
		var remapKeyModBit = ModBit(remap.Key);
		
		var modsToRelease = (byte)(entry.Mods & ~(remap.Mods | remapKeyModBit));
		var modsToPress   = (byte)(remap.Mods & ~entry.Mods);
		
		_vMods = (byte)(remap.Mods | remapKeyModBit);
		_currRemap = new RemapItem(entry, remap);
		_suppressedEntryMods = entry.Mods;
		
		Console.WriteLine($"Remap: {entry.Mods:b8}_0x{entry.Key:X} -> {remap.Mods:b8}_0x{remap.Key:X} ({_vMods:b8})");
		
		// TODO: MenuMask
		
		new KeySender(stackalloc InputItem[9])
			.ModsUp(modsToRelease)
			.ModsDown(modsToPress)
			.KeyDown(remap.Key)
			.Send();
		
		return true;
	}
	
	private static bool HandleUnicodeDown(Entry entry, string str)
	{
		var inputs = new INPUT[str.Length*2];
		
		for (int i = 0, j = 0; i < str.Length; i++)
		{
			var high = (ushort)str[i];
			if (high < 0xD800)
			{
				inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE, MAGNUM_CALLNEXT);
				inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, MAGNUM_CALLNEXT);
				continue;
			}
			
			var low = (ushort)str[++i];
			inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE, MAGNUM_CALLNEXT);
			inputs[j++] = INPUT.KeybdInput(low,  KEYEVENTF_UNICODE, MAGNUM_CALLNEXT);
			inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, MAGNUM_CALLNEXT);
			inputs[j++] = INPUT.KeybdInput(low,  KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, MAGNUM_CALLNEXT);
		}
		
		var modsToRelease = entry.Mods;
		_vMods = 0;
		_currUnicode = new UnicodeItem(entry, inputs);
		_suppressedEntryMods = modsToRelease;
		
		Console.WriteLine($"Unicode: 0x{entry.Key:X} -> {str}");
		
		if (modsToRelease != 0)
		{
			UpdateModsMaskedUnicode(modsToRelease, false);
		}
		
		SendInput((uint)inputs.Length, ref MemoryMarshal.GetReference(inputs), INPUT.Size);
		return true;
	}
	
	private static void UpdateModsMaskedUnicode(byte mods, bool down)
	{
		const byte menuMods = Mod.LA | Mod.RA | Mod.LW | Mod.RW;
		var toMask = (mods & menuMods) != 0 && (mods & (Mod.LC | Mod.RC)) == 0;
		
		var ks = new KeySender(stackalloc InputItem[8]);
		
		if (toMask) ks.MaskDown();
		ks.AddMods(mods, down);	
		if (toMask) ks.MaskUp();
		
		ks.Send();
	}
	
	private static void AddKeysToIgnoreList(byte modBits, ushort key)
	{
		if (modBits != 0)
		{
			if ((modBits & Mod.LC) != 0) _suppressedKeys.Add(Key.LCtrl);
			if ((modBits & Mod.LS) != 0) _suppressedKeys.Add(Key.LShift);
			if ((modBits & Mod.LA) != 0) _suppressedKeys.Add(Key.LAlt);
			if ((modBits & Mod.LW) != 0) _suppressedKeys.Add(Key.LWin);
			if ((modBits & Mod.RC) != 0) _suppressedKeys.Add(Key.RCtrl);
			if ((modBits & Mod.RS) != 0) _suppressedKeys.Add(Key.RShift);
			if ((modBits & Mod.RA) != 0) _suppressedKeys.Add(Key.RAlt);
			if ((modBits & Mod.RW) != 0) _suppressedKeys.Add(Key.RWin);
		}
		
		_suppressedKeys.Add(key);
	}
	
	private static byte ModBit(ushort sc) => sc switch
	{
		Key.LCtrl  => Mod.LCtrl,
		Key.LShift => Mod.LShift,
		Key.LAlt   => Mod.LAlt,
		Key.LWin   => Mod.LWin,
		Key.RCtrl  => Mod.RCtrl,
		Key.RShift => Mod.RShift,
		Key.RAlt   => Mod.RAlt,
		Key.RWin   => Mod.RWin,
		_ => 0
	};
	
	private static bool IsMod(ushort sc, out byte modBit)
	{
		modBit = ModBit(sc);
		return modBit != 0;
	}
	
	private static void SendKeyDown(ushort sc) => SendKey(sc, true);
	
	private static void SendKey(ushort sc, bool state)
	{
		var flags = KEYEVENTF_SCANCODE | (sc >> 8 != 0 ? KEYEVENTF_EXTENDEDKEY : 0) | (state ? 0 : KEYEVENTF_KEYUP);
		
		var input = INPUT.KeybdInput(sc, (uint)flags, MAGNUM_CALLNEXT);
		_ = SendInput(1, ref input, INPUT.Size);
	}
}
