using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;
using Lib.Hotkeys.Constants;
using Lib.Interop;
using Lib.Shared;
using Lib.Shared.Collections;
using static Lib.Hotkeys.Constants.Misc;
using static Lib.Interop.User32;
using static Lib.Interop.Constants;
using static Lib.Interop.Structs;

namespace Lib.Hotkeys;

// ReSharper disable InconsistentNaming

internal readonly record struct RemapItem(Entry Entry, Remap Remap);
internal readonly record struct UnicodeItem(Entry Entry, int Length, INPUT[] Inputs);
internal readonly record struct ActionItem(Entry Entry, KeyEvent KeyUp);

public static class InputHook
{
	private static readonly Dictionary<Entry, Func<Hotkey>> _hotkeys = [];
	
	private static readonly HotstringTrie _hotstrings = new();
	private static readonly Deque<char> _inputBuffer = new(HotstringMaxBufferSize);
	
	private static readonly Thread _hookThread = new(StartHook);
	private static uint _hookThreadId;
	
	private static byte _vMods;
	
	private static readonly HashSet<ushort> _suppressedKeys = [];
	
	private static RemapItem? _currRemap;
	private static UnicodeItem? _currUnicode;
	private static ActionItem? _currAction;
	
	internal static void Start()
	{
		SendKeyUp(Key.LCtrl); // TODO: remove once implement uiAccess
		
		MapHotkeys();
		MapHotstrings();
		_hookThread.Start();
	}
	
	internal static void ExitWait()
	{
		if (!PostThreadMessage(_hookThreadId, WM_QUIT, 0, 0))
		{
			throw new Exception(Marshal.GetLastPInvokeErrorMessage());
		}
		_hookThread.Join();
	}
	
	private static unsafe void StartHook()
	{
		// TODO: If Hotkey.Exit() is called before we happen to initialize this field, PostThreadMessage will fail.
		_hookThreadId = Kernel32.GetCurrentThreadId();
		
		using var hHook = SetWindowsHookEx(WH_KEYBOARD_LL, &LowLevelKeyboardProc, 0, 0);
		Debug.WriteLineEx("Hook is set");
		
		int res;
		while((res = GetMessage(out var msg, IntPtr.Zero, 0, 0)) != 0)
		{
			if (res == -1)
			{
				throw new Exception(Marshal.GetLastPInvokeErrorMessage());
			}
			_ = TranslateMessage(ref msg);
			_ = DispatchMessage(ref msg);
		}
		
		Debug.WriteLineEx("Message queue is terminated");
	}
	
	private static void MapHotkeys()
	{
		var methods = Assembly.GetEntryAssembly()!
			.GetTypes()
			.SelectMany(t => t.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic))
			.Where(m => m.CustomAttributes.Any(a => a.AttributeType == typeof(HotkeyAttribute)));
		
		foreach (var method in methods)
		{
			if (method.ReturnType != typeof(Hotkey) || method.GetParameters().Length != 0)
			{
				throw new NotImplementedException("Invalid function signature");
			}
			
			var handler = method.CreateDelegate<Func<Hotkey>>();
			
			foreach (var attribute in method.GetCustomAttributes<HotkeyAttribute>())
			{
				_hotkeys.Add(attribute.Entry, handler);
			}
		}
	}
	
	private static void MapHotstrings()
	{
		var methods = Assembly.GetEntryAssembly()!
			.GetTypes()
			.SelectMany(t => t.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic))
			.Where(m => m.CustomAttributes.Any(a => a.AttributeType == typeof(HotstringAttribute)));
		
		foreach (var method in methods)
		{
			if (method.ReturnType != typeof(Hotstring) || method.GetParameters().Length != 0)
			{
				throw new NotImplementedException("Invalid function signature");
			}
			
			var func = method.CreateDelegate<Func<Hotstring>>();
			
			foreach (var attribute in method.GetCustomAttributes<HotstringAttribute>())
			{
				_hotstrings.Add(attribute.Entry, func);
			}
		}
	}
	
	[UnmanagedCallersOnly]
	// The reason for using 'raw pointer' for 'lParam' instead of `ref' is the:
	// error CS8977: Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.
	private static unsafe nint LowLevelKeyboardProc(int code, nuint wParam, KBDLLHOOKSTRUCT* lParam)
	{
		if (code < 0) goto CallNext;
		
		var hookStruct = *lParam;
		
		var extra = hookStruct.dwExtraInfo;
		if (extra == MAGNUM_CALLNEXT) goto CallNext;
		
		var flags = hookStruct.flags;
		var sc = (ushort)hookStruct.scanCode;
		
		// TODO: accept injected keys from other apps? What about Alt_Down + Alt_Up generated by JetBrains Rider
		// on Alt release? Could it cause unwanted behavior?
		if ((flags & LLKHF_INJECTED) != 0)
		{
			// Media keys are (for some reason) 'injected', and 'sc' is set to 0. So we fall back on Vk.
			if (sc != 0 || hookStruct.vkCode is < VK_CONSUMER_BEGIN or > VK_CONSUMER_END)
			{
				Debug.WriteLineEx($"Ignore injected: 0x{sc:X} (vk 0x{hookStruct.vkCode:X})");
				
				if ((flags & LLKHF_UP) != 0) // most likely JetBrains Rider tapping Alt on its release
				{
					// Apparently, only one app at a time is permitted to «steal» the keyboard focus. If any other app sends
					// synthetic <key>Up event, they will take the precedence and all the subsequent calls to
					// SetForegroundWindow will fail for us (until we repetitively send <key>Up event).
					SendKeyUp(Key.LCtrl); // TODO: remove once implement uiAccess
				}
				
				return NonZero;
			}
			
			// It is said that if the scan code is an extended key, the high byte of the returned value will contain
			// either 0xE0 or 0xE1. However, SendInput seems to ignore high byte value and just specifying
			// 'KEYEVENTF_EXTENDEDKEY' flag seems to be enough. So the possible discrepancy should not bother.
			sc = (ushort)MapVirtualKey(hookStruct.vkCode, MAPVK_VK_TO_VSC_EX);
		}
		else if ((flags & LLKHF_EXTENDED) != 0 && sc != Key.RShift)
		{
			sc |= 0xE000;
		}
		
		bool isPressed = (flags & LLKHF_UP) == 0;
		bool isMod = IsMod(sc, out byte modBit);
		
		Debug.WriteLineEx($"{(isPressed ? "Down" : "Up")}: 0x{sc:X} ({_vMods:b8}); flags: {flags:b8}");
		
		if (isPressed)
		{
			if (HandleKbKeyDown(sc, isMod, modBit)) return NonZero;
			if (isMod) _vMods |= modBit;
		}
		else
		{
			if (HandleKbKeyUp(sc, isMod, modBit)) return NonZero;
			if (isMod) _vMods &= (byte)~modBit;
		}
		
		Debug.WriteLineEx($"Pass next: 0x{sc:X} ({_vMods:b8})");
		
		CallNext:
		return CallNextHookEx(0, code, wParam, lParam);
	}
	
	private static bool HandleKbKeyDown(ushort sc, bool isMod, byte modBit)
	{
		if (_suppressedKeys.Contains(sc))
		{
			Debug.WriteLineEx($"Suppress key down: 0x{sc:X}");
			return true;
		}
		
		if (_currRemap is {} r)
		{
			Debug.Assert(_currUnicode is null);
			Debug.Assert(_currAction is null);
			return HandleRemapRepeat(r, sc, isMod, modBit);
		}
		
		if (_currUnicode is {} u)
		{
			Debug.Assert(_currAction is null);
			return HandleUnicodeRepeat(u, sc, isMod, modBit);
		}
		
		if (_currAction is {} a)
		{
			if (a.Entry.Key == sc)
			{
				Debug.WriteLineEx("Action still in progress");
				return true;
			}
			
			if (isMod && (a.Entry.Mods & modBit) != 0)
			{
				Debug.WriteLineEx($"Suppress entry mod: {modBit:b8} (0x{sc:X})");
				return true;
			}
			
			return false;
		}
		
		var entry = new Entry(_vMods, sc);
		if (!_hotkeys.TryGetValue(entry, out var func))
		{
			return !isMod && HandleHotstring(sc); // TODO: clear buffer in other places
		}
		
		var hotkey = func();
		
		if (hotkey.IsRemap) return HandleRemapDown(entry, hotkey.Remap);
		if (hotkey.IsUnicode) return HandleUnicodeDown(entry, hotkey.Unicode);
		Debug.Assert(hotkey.IsAction); return HandleActionDown(entry, hotkey.Action);
	}

	private static bool HandleKbKeyUp(ushort sc, bool isMod, byte modBit)
	{
		if (_suppressedKeys.Remove(sc))
		{
			Debug.WriteLineEx($"Suppress key up: 0x{sc:X}");
			return true;
		}
		
		if (_currRemap is {} r)
		{
			Debug.Assert(_currUnicode is null);
			Debug.Assert(_currAction is null);
			return HandleRemapUp(r, sc, isMod, modBit);
		}
		
		if (_currUnicode is {} u)
		{
			Debug.Assert(_currAction is null);
			return HandleUnicodeUp(u, sc, isMod, modBit);
		}
		
		if (_currAction is {} a && a.Entry.Key == sc)
		{
			try { a.KeyUp.Set(); }
			catch (ObjectDisposedException) { }
			return true;
		}
		
		return false;
	}
	
	private static bool HandleRemapDown(Entry entry, Remap remap)
	{
		_currRemap = new RemapItem(entry, remap);
		if (remap == default) return false;
		
		var remapKeyModBit = ModBit(remap.Key);
		var modsToRelease = (byte)(entry.Mods & ~(remap.Mods | remapKeyModBit));
		var modsToPress   = (byte)(remap.Mods & ~entry.Mods);
		
		_vMods = (byte)(remap.Mods | remapKeyModBit);
		
		Debug.WriteLineEx($"Remap: {entry.Mods:b8}_0x{entry.Key:X} -> {remap.Mods:b8}_0x{remap.Key:X} ({_vMods:b8})");
		
		bool mask = ShouldMask(modsToRelease);
		var size = BitOperations.PopCount((byte)(modsToPress | modsToRelease)) + (mask ? 2 : 0) + 1;
		
		var ks = new KeySender(stackalloc INPUT[size]);
		if (modsToRelease != 0) ks.ModsUp(modsToRelease, mask);
		if (modsToPress   != 0) ks.ModsDown(modsToPress);
		ks.KeyDown(remap.Key).Send();
		
		return true;
	}
	
	private static bool HandleRemapUp(RemapItem r, ushort sc, bool isMod, byte modBit)
	{
		if (r.Entry.Key == sc)
		{
			_currRemap = null;
			if (r.Remap == default) return false;
			
			// Note: If one or all of the 'Remap.Mods' were already released, it will not be considered, and they will be
			// 'released' anyway. Can that be undesired?
			
			var keyToRelease  = r.Remap.Key;
			var modsToRelease = (byte)(r.Remap.Mods & ~r.Entry.Mods);
			var modsToRestore = (byte)(r.Entry.Mods & ~r.Remap.Mods);
			
			_vMods = (byte)((_vMods & ~(modsToRelease | ModBit(keyToRelease))) | modsToRestore);
		
			bool mask = ShouldMask(modsToRestore);
			var isWheel = Helper.IsMouseWheel(keyToRelease);
			var size = BitOperations.PopCount((byte)(modsToRelease | modsToRestore)) + (mask ? 2 : 0) + (isWheel ? 0 : 1);
			
			if (size != 0)
			{
				var ks = new KeySender(stackalloc INPUT[size]);
				if (!isWheel) ks.KeyUp(keyToRelease);
				if (modsToRelease != 0) ks.ModsUp(modsToRelease);
				if (modsToRestore != 0) ks.ModsDown(modsToRestore, mask);
				ks.Send();
			}
			
			return true;
		}
		
		if (isMod && (r.Entry.Mods & modBit) != 0)
		{
			_currRemap = null;
			if (r.Remap == default) return false;
			
			var keyToRelease  = r.Remap.Key;
			var modsToRelease = r.Remap.Mods;
			
			_vMods &= (byte)~(modsToRelease | ModBit(keyToRelease));
			AddKeysToIgnoreList((byte)(r.Entry.Mods & ~modBit), r.Entry.Key); // exclude the released bit
			
			// TODO: restore physically held mods?
			
			var isWheel = Helper.IsMouseWheel(keyToRelease);
			var size = BitOperations.PopCount(modsToRelease) + (isWheel ? 0 : 1);
			
			if (size != 0)
			{
				var ks = new KeySender(stackalloc INPUT[size]);
				if (!isWheel) ks.KeyUp(keyToRelease);
				if (modsToRelease != 0) ks.ModsUp(modsToRelease);
				ks.Send();
			}
			
			return true;
		}
		
		return false;
	}
	
	private static bool HandleRemapRepeat(RemapItem r, ushort sc, bool isMod, byte modBit)
	{
		if (r.Entry.Key == sc)
		{
			if (r.Remap == default) return false;
			
			var remapKey = r.Remap.Key;
			
			if (Helper.IsMouseButton(remapKey))
			{
				Debug.WriteLineEx("Repeat suppressed (mouse button)");
				return true;
			}
			
			Debug.WriteLineEx($"Repeat: {r.Entry.Mods:b8}_0x{sc:X} -> {r.Remap.Mods:b8}_0x{remapKey:X} ({_vMods:b8})");
			
			if (sc == remapKey) return false;
			SendKeyDown(remapKey);
			return true;
		}
		
		if (isMod && (r.Entry.Mods & modBit) != 0)
		{
			Debug.WriteLineEx($"Suppress entry mod: {modBit:b8} (0x{sc:X})");
			return true;
		}
		
		if (IsMod(r.Remap.Key)) return false; // maybe support compositional hotkeys, someday

		var entry = new Entry((byte)((_vMods & ~r.Remap.Mods) | r.Entry.Mods), sc);
		if (!_hotkeys.TryGetValue(entry, out var func)) return false;

		Debug.WriteLineEx("Remap interrupt");
		
		_currRemap = null;
		_suppressedKeys.Add(r.Entry.Key);

		if (r.Remap == default)
		{
			SendKeyUp(r.Entry.Key);
			goto MapHotkey;
		}

		var keyToRelease  = r.Remap.Key;
		var modsToRelease = (byte)(r.Remap.Mods & ~r.Entry.Mods);
		var modsToRestore = (byte)(r.Entry.Mods & ~r.Remap.Mods);

		_vMods = (byte)((_vMods & ~modsToRelease) | modsToRestore);

		bool mask = ShouldMask(modsToRestore);
		var isWheel = Helper.IsMouseWheel(keyToRelease);
		var size = BitOperations.PopCount((byte)(modsToRelease | modsToRestore)) + (mask ? 2 : 0) + (isWheel ? 0 : 1);

		if (size != 0)
		{
			var ks = new KeySender(stackalloc INPUT[size]);
			if (!isWheel) ks.KeyUp(keyToRelease);
			if (modsToRelease != 0) ks.ModsUp(modsToRelease);
			if (modsToRestore != 0) ks.ModsDown(modsToRestore, mask);
			ks.Send();
		}

		MapHotkey:
		var hotkey = func();
		
		if (hotkey.IsRemap) return HandleRemapDown(entry, hotkey.Remap);
		if (hotkey.IsUnicode) return HandleUnicodeDown(entry, hotkey.Unicode);
		Debug.Assert(hotkey.IsAction); return HandleActionDown(entry, hotkey.Action);
	}
	
	private static bool HandleUnicodeDown(Entry entry, string? str)
	{
		if (str is null) // Hotkey.Suppress
		{
			_suppressedKeys.Add(entry.Key);
			Debug.WriteLineEx($"Suppress: 0x{entry.Key:X}");
			return true;
		}
		
		var length = str.Length * 2;
		var inputs = ArrayPool<INPUT>.Shared.Rent(length);
		
		FillUnicodeChars(str, inputs);
		
		_vMods = 0;
		_currUnicode = new UnicodeItem(entry, length, inputs);
		
		Debug.WriteLineEx($"Unicode: 0x{entry.Key:X} -> '{str}'");
		
		var modsToRelease = entry.Mods;
		if (modsToRelease != 0)
		{
			bool mask = ShouldMask(modsToRelease);
			var size = BitOperations.PopCount(modsToRelease) + (mask ? 2 : 0);
			new KeySender(stackalloc INPUT[size]).ModsUp(modsToRelease, mask).Send();
		}
		
		SendInput((uint)length, ref MemoryMarshal.GetReference(inputs), INPUT.Size);
		return true;
	}
	
	private static bool HandleUnicodeUp(UnicodeItem u, ushort sc, bool isMod, byte modBit)
	{
		byte modsToRestore;
			
		if (u.Entry.Key == sc)
		{
			modsToRestore = u.Entry.Mods;
		}
		else if (isMod && (u.Entry.Mods & modBit) != 0)
		{
			modsToRestore = (byte)(u.Entry.Mods & ~modBit);
			_suppressedKeys.Add(u.Entry.Key);
		}
		else return false;
		
		ArrayPool<INPUT>.Shared.Return(u.Inputs);
		_currUnicode = null;
		_vMods |= modsToRestore;
		
		if (modsToRestore != 0)
		{
			bool mask = ShouldMask(modsToRestore);
			var size = BitOperations.PopCount(modsToRestore) + (mask ? 2 : 0);
			new KeySender(stackalloc INPUT[size]).ModsDown(modsToRestore, mask).Send();
		}
		
		return true;
	}
	
	private static bool HandleUnicodeRepeat(UnicodeItem u, ushort sc, bool isMod, byte modBit)
	{
		if (u.Entry.Key == sc)
		{
			Debug.WriteLineEx("Repeat Unicode");
			SendInput((uint)u.Length, ref MemoryMarshal.GetReference(u.Inputs), INPUT.Size);
			return true;
		}
		
		if (isMod && (u.Entry.Mods & modBit) != 0)
		{
			Debug.WriteLineEx($"Suppress entry mod: {modBit:b8} (0x{sc:X})");
			return true;
		}
		
		var entry = new Entry((byte)(_vMods | u.Entry.Mods), sc);
		if (!_hotkeys.TryGetValue(entry, out var func)) return false;

		Debug.WriteLineEx("Unicode interrupt");

		var modsToRestore = u.Entry.Mods;

		ArrayPool<INPUT>.Shared.Return(u.Inputs);
		_currUnicode = null;
		_vMods |= modsToRestore;
		_suppressedKeys.Add(u.Entry.Key);

		if (modsToRestore != 0)
		{
			var mask = ShouldMask(modsToRestore);
			var size = BitOperations.PopCount(modsToRestore) + (mask ? 2 : 0);
			new KeySender(stackalloc INPUT[size]).ModsDown(modsToRestore, mask).Send();
		}

		var hotkey = func();
		
		if (hotkey.IsRemap) return HandleRemapDown(entry, hotkey.Remap);
		if (hotkey.IsUnicode) return HandleUnicodeDown(entry, hotkey.Unicode);
		Debug.Assert(hotkey.IsAction); return HandleActionDown(entry, hotkey.Action);
	}
	
	private static bool HandleActionDown(Entry entry, Action<KeyEvent> action)
	{
		var keyEvent = new KeyEvent();
		_currAction = new ActionItem(entry, keyEvent);
		
		Debug.WriteLineEx("Action");
		
		ThreadPool.QueueUserWorkItem(static x =>
		{
			try { x.Key(x.Value); }
			finally
			{
				// TODO: Synchronize with the call to KeyEvent.Set() to avoid race-conditions.
				// Such conditions can lead to one of the following outcomes:
				// - Cancel() is called after the source has been disposed -> ObjectDisposedException;
				// - Dispose() is called during the transition to NotifyingState -> wait handle is not disposed leaving
				//   cleanup to finalization.
				
				var keyEvent = _currAction.Value.KeyUp;
				_currAction = null;
				keyEvent.Dispose();
			}
		}, new KeyValuePair<Action<KeyEvent>, KeyEvent>(action, keyEvent), false);
		
		return true;
	}
	
	private static bool HandleHotstring(ushort sc)
	{
		if (sc == Key.Space) // end-key
		{
			if (_inputBuffer.IsEmpty || (_vMods & (Mod.LCAW | Mod.RCAW)) != 0)
			{
				return false;
			}
			
			if (!_hotstrings.TryFind(_inputBuffer, out var entry, out var func))
			{
				_inputBuffer.AddLast(' ', FullMode.DropOldest);
				return false;
			}
			
			_inputBuffer.Clear();
			
			var hotstring = func();
			var replacement = hotstring.Replacement;
			
			if (replacement == "")
			{
				if (!hotstring.DeleteTyped) // Hotstring.Skip
				{
					Debug.WriteLineEx("Skip hotstring");
					return false;
				}
				
				// Hotstring.Erase
				Debug.WriteLineEx("Erase hotstring");
				new KeySender(stackalloc INPUT[entry.Length * 2]).TapKey(Key.Backspace, entry.Length).Send();
				return true; // TODO: what about the Space Up event?
			}
			
			Debug.WriteLineEx($"Hotstring: '{entry}' -> '{replacement}'");
			
			switch (hotstring.Mode)
			{
			case Hotstring.SendMode.Default:
				throw new NotImplementedException();
			
			case Hotstring.SendMode.Text:
				var length = replacement.Length * 2;
				if (hotstring.DeleteTyped)
				{
					length += entry.Length * 2;
				}
				
				var inputs = ArrayPool<INPUT>.Shared.Rent(length);
				Span<INPUT> inputsSpan = inputs;
				
				if (hotstring.DeleteTyped)
				{
					var down = INPUT.KeybdKey(Key.Backspace, true);
					var up = INPUT.KeybdKey(Key.Backspace, false);
					
					for (int i = 0; i < entry.Length * 2; i+=2)
					{
						inputsSpan[i] = down;
						inputsSpan[i+1] = up;
					}
					
					inputsSpan = inputsSpan[(entry.Length * 2)..];
				}
				
				FillUnicodeChars(replacement, inputsSpan);
				SendInput((uint)length, ref MemoryMarshal.GetReference(inputs), INPUT.Size);
				ArrayPool<INPUT>.Shared.Return(inputs);
				
				if (hotstring.OmitEndChar) return true; // TODO: what about the Space Up event?
				break;

			case Hotstring.SendMode.Clipboard:
				throw new NotImplementedException();
			
			default: throw new UnreachableException();
			}
			
			return false;
		}
		
		if (!Helper.TryGetKeyInfo(sc, out var key)) return false;
		
		switch (key.Type)
		{
		case KeyType.Letter:
		case KeyType.Symbol:
		case KeyType.Number:
			if ((_vMods & (Mod.LCAW | Mod.RCAW)) == 0)
			{
				_inputBuffer.AddLast((_vMods & (Mod.LS | Mod.RS)) != 0 ? key.Upper : key.Lower, FullMode.DropOldest);
			}
			break;
		
		case KeyType.Keypad:
			throw new NotImplementedException("KeyType.Keypad");
		
		case KeyType.Navigation:
			if (_inputBuffer.IsEmpty) break;
			
			if (sc is Key.Backspace)
			{
				if ((_vMods & ~(Mod.LC | Mod.RC)) == 0 && (_vMods & (Mod.LC | Mod.RC)) != 0)
				{
					_inputBuffer.Clear();
				}
				else
				{
					_inputBuffer.RemoveLast();
				}
				break;
			}
			
			if (sc is not (Key.Insert or Key.Delete))
			{
				_inputBuffer.Clear();
			}
			
			break;
		
		case KeyType.Function: break;
		
		default: throw new UnreachableException();
		}
		
		return false;
	}
	
	private static void FillUnicodeChars(ReadOnlySpan<char> text, Span<INPUT> inputs)
	{
		Debug.Assert(inputs.Length >= text.Length * 2);
		
		for (int i = 0, j = 0; i < text.Length; i++)
		{
			var high = (ushort)text[i];
			if (high < 0xD800)
			{
				inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE, MAGNUM_CALLNEXT);
				inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, MAGNUM_CALLNEXT);
				continue;
			}
			
			var low = (ushort)text[++i];
			inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE, MAGNUM_CALLNEXT);
			inputs[j++] = INPUT.KeybdInput(low,  KEYEVENTF_UNICODE, MAGNUM_CALLNEXT);
			inputs[j++] = INPUT.KeybdInput(high, KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, MAGNUM_CALLNEXT);
			inputs[j++] = INPUT.KeybdInput(low,  KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, MAGNUM_CALLNEXT);
		}
	}
	
	private static void AddKeysToIgnoreList(byte modBits, ushort key)
	{
		if (modBits != 0)
		{
			if ((modBits & Mod.LC) != 0) _suppressedKeys.Add(Key.LCtrl);
			if ((modBits & Mod.LS) != 0) _suppressedKeys.Add(Key.LShift);
			if ((modBits & Mod.LA) != 0) _suppressedKeys.Add(Key.LAlt);
			if ((modBits & Mod.LW) != 0) _suppressedKeys.Add(Key.LWin);
			if ((modBits & Mod.RC) != 0) _suppressedKeys.Add(Key.RCtrl);
			if ((modBits & Mod.RS) != 0) _suppressedKeys.Add(Key.RShift);
			if ((modBits & Mod.RA) != 0) _suppressedKeys.Add(Key.RAlt);
			if ((modBits & Mod.RW) != 0) _suppressedKeys.Add(Key.RWin);
		}
		
		_suppressedKeys.Add(key);
	}
	
	private static byte ModBit(ushort sc) => sc switch
	{
		Key.LCtrl  => Mod.LCtrl,
		Key.LShift => Mod.LShift,
		Key.LAlt   => Mod.LAlt,
		Key.LWin   => Mod.LWin,
		Key.RCtrl  => Mod.RCtrl,
		Key.RShift => Mod.RShift,
		Key.RAlt   => Mod.RAlt,
		Key.RWin   => Mod.RWin,
		_ => 0
	};
	
	private static bool IsMod(ushort sc, out byte modBit) => (modBit = ModBit(sc)) != 0;
	
	private static bool IsMod(ushort sc) => ModBit(sc) != 0;
	
	private static bool ShouldMask(byte mods) => (mods & (Mod.LAW | Mod.RAW)) != 0 && (mods & (Mod.LC | Mod.RC)) == 0;
	
	private static void SendKeyDown(ushort sc) => SendKey(sc, true);
	
	private static void SendKeyUp(ushort sc) => SendKey(sc, false);
	
	private static void SendKey(ushort key, bool down)
	{
		var input = Helper.IsMouseKey(key) ? INPUT.MouseKey(key, down) : INPUT.KeybdKey(key, down);
		_ = SendInput(1, ref input, INPUT.Size);
	}
}
